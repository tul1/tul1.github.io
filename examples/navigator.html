<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Navigator</title>
	<style>
		@font-face {
			font-family: 'inconsolata';
			src: url('files/inconsolata.woff') format('woff');
			font-weight: normal;
			font-style: normal;
		}

		body {
			margin:0;
			font-family: 'inconsolata';
			font-size: 15px;
			line-height: 18px;
			overflow: hidden;
		}

		canvas { width: 100%; height: 100% }

		#newWindow {
			display: block;
			position: absolute;
			bottom: 0.3em;
			left: 0.5em;
			color: #fff;
		}
	</style>
</head>

<body>

	<a id="newWindow" href="https://threejs.org/docs/scenes/geometry-browser.html#PlaneGeometry" target="_blank">Open in New Window</a>
	<script src="../build/three.js"></script>

	<script src="js/libs/dat.gui.min.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/ParametricGeometries.js"></script>

	<script>
		document.getElementById( 'newWindow' ).href += window.location.hash;

		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		camera.position.z = 100;
		camera.position.y = 60;
		camera.position.x = 40;
		camera.lookAt(new THREE.Vector3(40,60,0));

		var renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor( 0xFFFFFF, 1 );
		document.body.appendChild( renderer.domElement );

		var controls = new THREE.OrbitControls( camera, renderer.domElement );


		var lights = [];
		lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );

		lights[ 0 ].position.set( 0, 200, 0 );
		lights[ 1 ].position.set( 100, 200, 100 );
		lights[ 2 ].position.set( - 100, - 200, - 100 );

		scene.add( lights[ 0 ] );
		scene.add( lights[ 1 ] );
		scene.add( lights[ 2 ] );

		var TILE_LENGTH = 20;

		var COLOR_OFF = 0x156289;
		var EMISSIVE_OFF = 0x072534;

		var COLOR_ON = 0x891528;
		var EMISSIVE_ON = 0x892815;

		var triangleVectors=[
			[new THREE.Vector3(0,-TILE_LENGTH/2,0), new THREE.Vector3(TILE_LENGTH/2,-TILE_LENGTH/2,0), new THREE.Vector3(0,0,0)],
			[new THREE.Vector3(TILE_LENGTH/2,-TILE_LENGTH/2,0), new THREE.Vector3(TILE_LENGTH/2, 0, 0), new THREE.Vector3(0,0,0)]
		];

		var floor=[];
		var nX=4;
		var nY=7;

		for(var x=0; x<nX; x++){
			for(var y=0; y<nY; y++){
				var tile=[];
				var n=0;
				for(var i=0; i<4; i++){
					for(var j=0; j<2; j++){
						var triangle = new THREE.Object3D();
						var lineMaterial = new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.5});
						var triangleMaterial = new THREE.MeshPhongMaterial({color:COLOR_OFF ,emissive:EMISSIVE_OFF ,side:THREE.DoubleSide, shading:THREE.FlatShading});

						var geometry = new THREE.Geometry();
						geometry.vertices.push(	triangleVectors[j][0], triangleVectors[j][1], triangleVectors[j][2] );
						var face = new THREE.Face3(0, 1, 2);
						geometry.faces.push(face);

						triangle.add(new THREE.LineSegments(new THREE.Geometry(), lineMaterial));
						triangle.add( new THREE.Mesh( new THREE.Geometry(), triangleMaterial));

						triangle.children[ 0 ].geometry = new THREE.WireframeGeometry(geometry);
						triangle.children[ 1 ].geometry = geometry;


						triangle.rotation.z = Math.PI*i/2;
						triangle.position.x = TILE_LENGTH*x;
						triangle.position.y = TILE_LENGTH*y;

						n++;
						tile.push({'triangle':triangle,'number':n,'state':"OFF"});
						
						scene.add(triangle);
					}
				}
				floor.push({'tile':tile,'x':x,'y':y});
			}
		}

		var frame=0;
		var step =0;
		var subStep=0;
		var MAX_STEP=30;
		var render = function () {

			requestAnimationFrame(render);
			renderer.render(scene,camera);

			if(step>pathUpdates.length-1){
				step=0;
			}
			if(subStep>=MAX_STEP){
				subStep=0;
			}

			if(frame%MAX_STEP == 0){
				updateFloorState(step);
				step++;
				subStep=0;
			}
			updateNavigatorPosition(step,subStep,MAX_STEP);
			subStep++;
			frame++;
		};


		var pathUpdates=[
			[ {'x': 2,'y': 0, 'number': 1}, {'x': 2,'y': 0, 'number': 2}, {'x': 2,'y': 0, 'number': 3} ],
			[ {'x': 2,'y': 0, 'number': 4}, {'x': 2,'y': 0, 'number': 5}, {'x': 2,'y': 0, 'number': 6} ],
			[ {'x': 2,'y': 1, 'number': 1}, {'x': 2,'y': 1, 'number': 2}, {'x': 2,'y': 1, 'number': 3} ],
			[ {'x': 2,'y': 1, 'number': 4}, {'x': 2,'y': 1, 'number': 5}, {'x': 2,'y': 1, 'number': 6} ],
			[ {'x': 2,'y': 2, 'number': 1}, {'x': 2,'y': 2, 'number': 2}, {'x': 2,'y': 2, 'number': 3} ],
			[ {'x': 2,'y': 2, 'number': 4}, {'x': 2,'y': 2, 'number': 5}, {'x': 2,'y': 2, 'number': 6} ],
			[ {'x': 2,'y': 3, 'number': 1}, {'x': 2,'y': 3, 'number': 2}, {'x': 2,'y': 3, 'number': 3} ],
			[ {'x': 2,'y': 3, 'number': 4}, {'x': 2,'y': 3, 'number': 5}, {'x': 2,'y': 3, 'number': 6} ],
			[ {'x': 2,'y': 4, 'number': 1}, {'x': 2,'y': 4, 'number': 2}, {'x': 2,'y': 4, 'number': 3} ],
			[ {'x': 2,'y': 4, 'number': 4}, {'x': 2,'y': 4, 'number': 5}, {'x': 2,'y': 4, 'number': 6} ],
			[ {'x': 2,'y': 5, 'number': 1}, {'x': 2,'y': 5, 'number': 2}, {'x': 2,'y': 5, 'number': 3} ],
			[ {'x': 2,'y': 5, 'number': 4}, {'x': 2,'y': 5, 'number': 5}, {'x': 2,'y': 5, 'number': 6} ],
			[ {'x': 2,'y': 6, 'number': 1}, {'x': 2,'y': 6, 'number': 2}, {'x': 2,'y': 6, 'number': 3} ],
			[ {'x': 2,'y': 6, 'number': 4}, {'x': 2,'y': 6, 'number': 5}, {'x': 2,'y': 6, 'number': 6} ]
		];

		function updateFloorState(step){
			for(var i=0;i<floor.length; i++){
				for(var j=0;j<floor[i].tile.length; j++){

					floor[i].tile[j].triangle.children[1].material.color.set(COLOR_OFF);
					floor[i].tile[j].state="OFF";

					for(var k=0; k<pathUpdates[step].length; k++){
						if(pathUpdates[step][k].x == floor[i].x &&
							pathUpdates[step][k].y == floor[i].y && 
							pathUpdates[step][k].number == floor[i].tile[j].number){
							floor[i].tile[j].triangle.children[1].material.color.set(COLOR_ON);
							floor[i].tile[j].state="ON";
						}
					}
				}
			}
		}

		
		var sphereMaterial = new THREE.MeshPhongMaterial( {color:0x000000 ,emissive:0x000000 ,side:THREE.DoubleSide, shading:THREE.FlatShading} );
		var lineMaterial = new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.5});
		var sphere = new THREE.Object3D();
		sphere.add(new THREE.LineSegments(new THREE.Geometry(), lineMaterial));
		sphere.add( new THREE.Mesh( new THREE.SphereGeometry( TILE_LENGTH/8, 12, 12 ), sphereMaterial));
		sphere.position.z = 7.5;
		scene.add(sphere);

		function updateNavigatorPosition(step,subStep,MaxStep){
			if(step<pathUpdates.length){
				if(step){
					for(var k=0; k<pathUpdates[step].length; k++){
							sphere.position.x = ((pathUpdates[step][k].x-pathUpdates[step-1][0].x)*subStep/MaxStep+pathUpdates[step-1][0].x)*TILE_LENGTH;
							sphere.position.y = ((pathUpdates[step][k].y-pathUpdates[step-1][0].y)*subStep/MaxStep+pathUpdates[step-1][0].y)*TILE_LENGTH;					
					}					
				}else{
					sphere.position.x = pathUpdates[step][0].x*TILE_LENGTH;
					sphere.position.y = pathUpdates[step][0].y*TILE_LENGTH;
				}
			}
		}




		window.addEventListener( 'resize', function () {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}, false );

		render();

	</script>


	<canvas width="1920" height="502" style="width: 1536px; height: 402px;"></canvas>	

</body>
</html>