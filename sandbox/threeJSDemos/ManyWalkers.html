<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - animation - skinning</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>

      body {
        color: #000;
        font-family:Monospace;
        font-size:13px;
        text-align:center;

        background-color: #fff;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px; width: 100%;
        padding: 5px;
      }
    </style>


  </head>
  <body>
    <div id="container"></div>

    <script src="./js/Three.js"></script>
    <script src="./js/OrbitControls.js"></script>

    <script src="./js/Detector.js"></script>
    <script src="./js/dat.gui.min.js"></script>

    <script src="./js/SpeedBlendCharacter.js"></script>
    <script src="./js/CharacterController.js"></script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      window.onload = init;

      var container;

      var camera, skyCamera, scene, skyScene, renderer, controls;

      var light, lightOffset;
      var blendMesh = null;
      var characterController = null;

      var clock = new THREE.Clock();
      var gui = null;

      var isFrameStepping = false;
      var timeToStep = 0;
      var speed = 0, speedDelta = 0;


      // -----------------------------------------------------------------------
      function init() {

        container = document.getElementById( 'container' );

        scene = new THREE.Scene();

        scene.fog = new THREE.Fog( 0xB0CAE1, 1000.0, 20000.0 );
        scene.add ( new THREE.AmbientLight( 0xaaaaaa ) );

        lightOffset = new THREE.Vector3( 0, 1000, 1000.0 );

        light = new THREE.DirectionalLight( 0xffffff, 1.5 );
        light.position.copy( lightOffset );

        scene.add( light );

        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
        renderer.setClearColor( '#777777', 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.autoClear = false;
        renderer.shadowMapEnabled = true;
        renderer.shadowMapType = THREE.PCFSoftShadowMap;

        container.appendChild( renderer.domElement );

        camera = new THREE.PerspectiveCamera( 45, 3, 1, 20000 );
        camera.position.set( 0.0, 104 * 3, 104 * 3.5 );

        controls = new THREE.OrbitControls( camera );

        loadSkeletalMeshes();
        
      }
      var blendMeshes = [];
      var botNum = 4;
      function loadSkeletalMeshes(call) {
        for(var i=0; i<botNum; i++){
          blendMeshes[i] = new THREE.SpeedBlendCharacter();
          blendMeshes[i].load( "models/marine/marine_anims.js",dispachMeshLoadingEnd);          
        }
        
      }

      var modelLoaded=0;
      function dispachMeshLoadingEnd(){
        console.log("loadingEnded");
        modelLoaded++;
        if(modelLoaded==botNum)
          buildScene();
      }

      var botPositions = [{x:1,z:1}, {x:-1,z:1}, {x:1,z:-1}, {x:-1,z:-1}];
      var baseAngle = Math.PI / 4;
      var botAngles = [Math.PI / 4, Math.PI / 4 - Math.PI / 2, Math.PI / 4 + Math.PI/2 , Math.PI / 4- Math.PI];

      var charactersController=[];
      function buildScene() {
        for(var i=0; i < botNum; i++){
          blendMeshes[i].rotation.y = botAngles[i];

          blendMeshes[i].position.x = 200*botPositions[i].x;
          blendMeshes[i].position.z = 200*botPositions[i].z;

          scene.add(blendMeshes[i]);
          charactersController[i] = new THREE.CharacterController( blendMeshes[i] ); 
        }
        update();
      }


      function update() {

        requestAnimationFrame( update, renderer.domElement );
        var scale = 1;
        var delta = clock.getDelta();
        var stepSize = (!isFrameStepping) ? delta * scale: timeToStep;

        if ( stepSize > 0 ) {
          THREE.AnimationHandler.update( stepSize );
          for(var i=0; i<botNum; i++){
            charactersController[i].update( 0.1 );
            blendMeshes[i].updateSkeletonHelper();
          }
        }

        timeToStep = 0;
        renderer.clear();
        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>

